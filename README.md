[![npm](https://img.shields.io/npm/v/@tinkoff/shared-library-webpack-plugin)](https://www.npmjs.com/package/@tinkoff/shared-library-webpack-plugin)
[![npm](https://img.shields.io/npm/dm/@tinkoff/shared-library-webpack-plugin)](https://www.npmjs.com/package/@tinkoff/shared-library-webpack-plugin)

# SharedLibraryWebpackPlugin

SharedLibraryWebpackPlugin предназначен для шаринга библиотек между приложениями в рантайме.

## Мотивация

При загрузке нескольких бандлов разных приложений встал вопрос о минимизации размеров этих бандлов.
Так как бандлы имели очень много одинаковых зависимостей логично вынести и поставлять их отдельно.

После ряда исследований было принято решение о создании плагина для Webpack 4, который решает следующие проблемы:

1. Приложения остаются самодостаточным и автономными (т.е. не меняется механизм загрузки и почти не меняется сборка)
2. Самостоятельная загрузка недостающих модулей
3. Шаринг кода в рантайме
4. Разные версии библиотек работают независимо друг от друга

## Установка и пример конфигурации

Добавляем плагин в зависимости `package.json`:

```
npm install @tinkoff/shared-library-webpack-plugin -D
```

Добавляем плагин в конфигурацию webpack

```typescript
{
  plugins: [
    ...,
    new SharedLibraryWebpackPlugin({
      libs: ['lodash']
    }),
    ...
  ]
}
```

Сборки приложения с такой конфигурацией плагина будет содержать
отдельный чанк с библиотекой lodash. Чанк будет загружен в случае,
если lodash не был загружен ранее при инициализации другого приложения
с подобной конфигурацией.

## Так что же делает плагин?

Плагин вносит коррективы как в процесс сборки приложения (buildtime), так и в процесс запуска и проигрывания приложения (runtime).

### Buildtime

1. Происходит анализ сформированных чанков на наличие указанных библиотек.
   Каждая из найденных библиотек выделяется в отдельный чанк с отключением tree shaking(!).
   Все выделенные чанки с точки зрения webpack существуют сами по себе и не привязываются к entry points.
2. Модифицируется webpack runtime для записи и чтения результата выполнения и загрузки выделенных библиотек.
3. Модифицируется стандартная обертка entry points для проверки на уже существующие в runtime библиотеки.

### Runtime

1. Загружается entry points приложения
2. При загрузке entry point происходит проверка на загрузку зависимых библиотек.
3. Затем загружаются только недостающие библиотеки.
4. Загруженные выделенные библиотеки экспортируются в общий неймспейс в глобальном пространстве.
5. Инициализация entry points (запуск приложения)

## Шаринг библиотек с разными версиями

По умолчанию мы считаем, что все разработчики библиотек придерживаются semantic release. На основе этого соглашения можно предположить, что при шаринге нужно учитывать лишь мажор, минор и пререлизные версии. Именно такой шаблон {major}.{minor}-{prerelease} будет использоваться по умолчанию при поиске в runtime заруженного аналога используемой в entry point библиотеки.

### Что это значит?

Допустим, что одно из приложений поставляет `lodash`, как библиотеку которую можно переиспользовать, если она уже загружена.

```typescript
{
  plugins: [
    ...,
    new SharedLibraryWebpackPlugin({
      libs: 'lodash'
    }),
    ...
  ]
}
```

При сборке будет выделен соответствующий чанк с названием `lodash-4.16.js`, который содержит
выделенную библиотеку. В название чанка была включена версия библиотеки без учета патча.

Второе приложение имеет такую же конфигурацию, но отличную версию `lodash`. При сборке выделяется чанк с названием `lodash-4.17.js`.

При загрузке первого приложения будет загружен чанк `lodash-4.16.js`, так как очевидно `lodash` еще не загружался.
При этом будут проставлены метки, что чанк загружен и результат экспорта будет записан в глобальный неймспейс,
откуда он будет импортироваться следующими приложениями, имеющими аналогичную настройку.

При загрузке второго приложения в runtime будут проверен глобальный неймспейс на факт загрузки `lodash@4.17.x`,
но неймспейс не будет содержать ничего, кроме `lodash@4.16.x`. Но как было описано выше по умолчанию разница в миноре
считается несовместимой. По этому второе приложение так же загрузит lodash, но свою версию и будет при работе
использовать только ее.

Для изменения дефолтного поведения в конфигурации можно указать `suffix`, который заменит стандартный шаблон с версией пакета.

```typescript
{
  plugins: [
    ...,
    new SharedLibraryWebpackPlugin({
      libs: {name: 'lodash', suffix: 'someSuffix'}
    }),
    ...
  ]
}
```

В этом случае при сборке будет выделен чанк `lodash-someSuffix.js`. При загрузке двух приложений, использующих такой
конфиг `lodash` будет загружен один раз и переиспользован обоими приложениями,
даже если приложения имеют разные версии `lodash` в зависимостях.
